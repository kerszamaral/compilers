%{
// parser.ypp file made by Ian Kersz - 2025/1
#define EXIT_SYNTAX_ERROR 3
%}

// C++ parser
%language "c++"

// Use variant for value type, compatible with shared_ptr
%define api.value.type variant
// Use constructor for token type
%define api.token.constructor

%require "3.8" // Minimum version, disables generation of stack.hh file

%code requires {
    // C++ code required for the parser to work
    #include <memory>
    #include "scanner.hpp"
    #include "ast.hpp"

    using symbol = std::shared_ptr<Symbol>;
    using node = std::shared_ptr<Node>;
}

%code {
    // Declaration of the yylex function from lexer, correctly typed
    yy::parser::symbol_type yylex();
}

// Removes the warning about exactly one conflict still existing
%expect 1


%token KW_BYTE
%token KW_INT
%token KW_REAL
%token KW_IF
%token KW_ELSE
%token KW_DO
%token KW_WHILE
%token KW_READ
%token KW_PRINT
%token KW_RETURN
%token OPERATOR_LE
%token OPERATOR_GE
%token OPERATOR_EQ
%token OPERATOR_DIF
%token<symbol> TK_IDENTIFIER
%token<symbol> LIT_INT
%token<symbol> LIT_CHAR
%token<symbol> LIT_REAL
%token<symbol> LIT_STRING
%token TOKEN_ERROR

%token '-' ',' ';' ':' '(' ')' '{' '}' '[' ']' '+' '*' '/' '%' '<' '>' '&' '|' '~' '='


%type<node> init_val
%type<node> expr
%type<node> fun_call
%type<node> args
%type<node> arg_list


%left '~'
%left '&' '|'
%left '+' '-'
%left '*' '/' '%'
%left '<' '>' OPERATOR_LE OPERATOR_GE
%left OPERATOR_EQ OPERATOR_DIF

// Resolves the conflict between the if and else statements
%precedence then
%precedence KW_ELSE

%%

program
    : ldecl
    ;

ldecl
    : decl ldecl
    | %empty
    ;

decl
    : fun_decl
    | var_decl
    | vec_decl
    ;

var_decl
    : var_type TK_IDENTIFIER '='  init_val ';' {}
    ;

var_type
    : KW_INT
    | KW_REAL
    | KW_BYTE
    ;

init_val
    : LIT_INT   { $$ = make_node($1); }
    | LIT_REAL  { $$ = make_node($1); }
    | LIT_CHAR  { $$ = make_node($1); }
    ;

vec_decl
    : vec_def ';'
    | vec_def '=' vec_init ';'
    ;

vec_def
    : var_type TK_IDENTIFIER '[' LIT_INT ']'
    ;

vec_init
    : init_val {}
    | init_val ',' vec_init {}
    ;

fun_decl
    : var_type TK_IDENTIFIER '(' params ')' fun_body
    ;

params
    : param_list
    | %empty
    ;

param_list
    : param_decl ',' param_list
    | param_decl
    ;

param_decl
    : var_type TK_IDENTIFIER
    ;

fun_body
    : cmd_block
    ;

cmd_block
    : '{' cmd_list '}'
    ;

cmd_list
    : cmd cmd_list
    | %empty
    ;

cmd
    : atrib
    | flux_ctrl
    | read_cmd
    | print_cmd
    | return_cmd
    | empty_cmd
    | cmd_block
    ;

atrib
    : TK_IDENTIFIER '=' expr ';'
    | TK_IDENTIFIER '[' expr ']' '=' expr ';'
    ;

expr
    : init_val                      { $$ = $1; }
    | TK_IDENTIFIER                 { $$ = make_node($1); }
    | TK_IDENTIFIER '[' expr ']'    { $$ = make_node($1, {$3}); }
    | expr '+' expr                 { $$ = make_node(NODE_ADD, {$1, $3}); }
    | expr '-' expr                 { $$ = make_node(NODE_SUB, {$1, $3}); }
    | expr '*' expr                 { $$ = make_node(NODE_MUL, {$1, $3}); }
    | expr '/' expr                 { $$ = make_node(NODE_DIV, {$1, $3}); }
    | expr '%' expr                 { $$ = make_node(NODE_MOD, {$1, $3}); }
    | expr '<' expr                 { $$ = make_node(NODE_LT, {$1, $3}); }
    | expr '>' expr                 { $$ = make_node(NODE_GT, {$1, $3}); }
    | expr OPERATOR_LE expr         { $$ = make_node(NODE_LE, {$1, $3}); }
    | expr OPERATOR_GE expr         { $$ = make_node(NODE_GE, {$1, $3}); }
    | expr OPERATOR_EQ expr         { $$ = make_node(NODE_EQ, {$1, $3}); }
    | expr OPERATOR_DIF expr        { $$ = make_node(NODE_DIF, {$1, $3}); }
    | expr '&' expr                 { $$ = make_node(NODE_AND, {$1, $3}); }
    | expr '|' expr                 { $$ = make_node(NODE_OR, {$1, $3}); }
    | '~' expr                      { $$ = make_node(NODE_NOT, {$2}); }
    | fun_call                      { $$ = $1; }
    | '(' expr ')'                  { $$ = make_node(NODE_PARENTHESIS, {$2}); }
    ;

fun_call
    : TK_IDENTIFIER '(' args ')' { $$ = make_node(NODE_FUNC_CALL, {make_node($1), $3}); }
    ;

args
    : arg_list { $$ = $1; }
    | %empty { $$ = nullptr; }
    ;

arg_list
    : expr ',' arg_list { $$ = make_node(NODE_ARG_LIST, {$1, $3}); }
    | expr              { $$ = make_node(NODE_ARG_LIST, {$1}); }
    ;

flux_ctrl
    : if_cmd
    | while_cmd
    | do_while_cmd
    ;

if_cmd
    : KW_IF '(' expr ')' cmd %prec then     { print_tree(make_node(NODE_IF, {$3})); }
    | KW_IF '(' expr ')' cmd KW_ELSE cmd    { print_tree(make_node(NODE_IF, {$3})); }
    ;

while_cmd
    : KW_WHILE expr KW_DO cmd
    ;

do_while_cmd
    : KW_DO cmd KW_WHILE expr ';'
    ;

read_cmd
    : KW_READ TK_IDENTIFIER ';'
    ;

print_cmd
    : KW_PRINT print_list
    ;

// Causes conflict with expressiong, as we can have the following
// Function call: print  "AA"    test(1*2)   "BB"     ;
// Parsing:       PRINT  STRING  FUNC_CALL   STRING  ';'
// Expression:    print  "AA"    test  (1*2) "BB"     ;
// Parsing:       PRINT  STRING  EXPR  EXPR  STRING  ';'
// And they are both the same according to the grammar
print_list
    : expr print_list
    | LIT_STRING print_list { }
    | expr ';'
    | LIT_STRING ';' { }
    ;

return_cmd
    : KW_RETURN expr ';'
    ;

empty_cmd
    : ';'
    ;

%%

void yy::parser::error(const std::string& msg) {
    std::cerr << "Syntax Error at line " << getLineNumber() << ": " << msg << std::endl;
    std::exit(EXIT_SYNTAX_ERROR);
}